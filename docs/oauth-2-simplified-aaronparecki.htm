<html>
 <body>
  <div class="content-area has-name" style="">
   <div class="pad">
    <h2 class="p-name post-title">
     OAuth 2 Simplified
    </h2>
    <div class="post-text e-content">
     <p>
      This post describes OAuth 2.0 in a simplified format to help developers and service providers implement the protocol.
     </p>
     <p>
      The
      <a href="https://oauth.net/2/">
       OAuth 2 spec
      </a>
      can be a bit confusing to read, so I've written this post to help describe the terminology in a simplified format. The core spec leaves many decisions up to the implementer, often based on security tradeoffs of the implementation. Instead of describing all possible decisions that need to be made to successfully implement OAuth 2, this post makes decisions that are appropriate for most implementations.
     </p>
     <p>
      <a href="https://www.udemy.com/course/oauth-2-simplified/?referralCode=B04F59AED67B8DA74FA7">
       <img src="https://aaronparecki.com/oauth-2-simplified/nuts-and-bolts-of-oauth.png" style="width:100%; border-radius: 6px;"/>
      </a>
     </p>
     <div class="inline-banner">
      <p>
       Note: This post has been updated from the original 2012 version based on the current best practices of OAuth 2.0. The original version can be found
       <a href="https://aaronparecki.com/2012/07/29/7/oauth2-simplified">
        here
       </a>
       .
      </p>
     </div>
     <h2>
      Table of Contents
     </h2>
     <ul>
      <li>
       <a href="#roles">
        Roles
       </a>
       : Applications, APIs and Users
      </li>
      <li>
       <a href="#creating-an-app">
        Creating an App
       </a>
      </li>
      <li>
       <a href="#authorization">
        Authorization
       </a>
       : Obtaining an access token
       <ul>
        <li>
         <a href="#web-server-apps">
          Web Server Apps
         </a>
        </li>
        <li>
         <a href="#single-page-apps">
          Single-Page Apps
         </a>
        </li>
        <li>
         <a href="#mobile-apps">
          Mobile Apps
         </a>
        </li>
        <li>
         <a href="#others">
          Other Grant Types
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#making-authenticated-requests">
        Making Authenticated Requests
       </a>
      </li>
      <li>
       <a href="#differences">
        Differences from OAuth 1.0
       </a>
       <ul>
        <li>
         <a href="#authentication-and-signatures">
          Authentication and Signatures
         </a>
        </li>
        <li>
         <a href="#user-experience-and-alternative-authorization-flows">
          User Experience and Alternative Authorization Flows
         </a>
        </li>
        <li>
         <a href="#performance-at-scale">
          Performance at Scale
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#resources">
        Resources
       </a>
      </li>
     </ul>
     <h2 id="roles">
      Roles
     </h2>
     <h3>
      The Third-Party Application: "Client"
     </h3>
     <p>
      The client is the application that is attempting to get access to the user's account. It needs to get permission from the user before it can do so.
     </p>
     <h3>
      The API: "Resource Server"
     </h3>
     <p>
      The resource server is the API server used to access the user's information.
     </p>
     <h3>
      The Authorization Server
     </h3>
     <p>
      This is the server that presents the interface where the user approves or denies the request. In smaller implementations, this may be the same server as the API server, but larger scale deployments will often build this as a separate component.
     </p>
     <h3>
      The User: "Resource Owner"
     </h3>
     <p>
      The resource owner is the person who is giving access to some portion of their account.
     </p>
     <h2 id="creating-an-app">
      Creating an App
     </h2>
     <p>
      Before you can begin the OAuth process, you must first register a new app with the service. When registering a new app, you usually register basic information such as application name, website, a logo, etc. In addition, you must register a redirect URI to be used for redirecting users to for web server, browser-based, or mobile apps.
     </p>
     <h3>
      Redirect URIs
     </h3>
     <p>
      The service will only redirect users to a registered URI, which helps prevent some attacks. Any HTTP redirect URIs must be served via HTTPS. This helps prevent tokens from being intercepted during the authorization process. Native apps may register a redirect URI with a custom URL scheme for the application, which may look like
      <code>
       demoapp://redirect
      </code>
      .
     </p>
     <h3>
      Client ID and Secret
     </h3>
     <p>
      After registering your app, you will receive a client ID and optionally a client secret. The client ID is considered public information, and is used to build login URLs, or included in Javascript source code on a page. The client secret
      <strong>
       must
      </strong>
      be kept confidential. If a deployed app cannot keep the secret confidential, such as single-page Javascript apps or native apps, then the secret is not used, and ideally the service shouldn't issue a secret to these types of apps in the first place.
     </p>
     <h2 id="authorization">
      Authorization
     </h2>
     <p>
      The first step of OAuth 2 is to get authorization from the user. For browser-based or mobile apps, this is usually accomplished by displaying an interface provided by the service to the user.
     </p>
     <p>
      OAuth 2 provides several "grant types" for different use cases. The grant types defined are:
     </p>
     <ul>
      <li>
       <strong>
        Authorization Code
       </strong>
       for apps running on a
       <a href="#web-server-apps">
        web server
       </a>
       ,
       <a href="#browser-based-apps">
        browser-based
       </a>
       and
       <a href="#mobile-apps">
        mobile apps
       </a>
      </li>
      <li>
       <strong>
        Password
       </strong>
       for logging in with a
       <a href="#other-app-types">
        username and password
       </a>
       (only for first-party apps)
      </li>
      <li>
       <strong>
        Client credentials
       </strong>
       for
       <a href="#client-credentials">
        application access
       </a>
       without a user present
      </li>
      <li>
       <strong>
        Implicit
       </strong>
       was previously recommended for clients without a secret, but has been superseded by using the Authorization Code grant with PKCE.
      </li>
     </ul>
     <p>
      Each use case is described in detail below.
     </p>
     <h2 id="web-server-apps">
      Web Server Apps
     </h2>
     <p>
      Web server apps are the most common type of application you encounter when dealing with OAuth servers. Web apps are written in a server-side language and run on a server where the source code of the application is not available to the public. This means the application is able to use its client secret when communicating with the authorization server, which can help avoid many attack vectors.
     </p>
     <h3>
      Authorization
     </h3>
     <p>
      Create a "Log In" link sending the user to:
     </p>
     <pre><code>https://authorization-server.com/auth?response_type=code&amp;
  client_id=CLIENT_ID&amp;redirect_uri=REDIRECT_URI&amp;scope=photos&amp;state=1234zyx</code></pre>
     <ul>
      <li>
       <b>
        response_type=code
       </b>
       - Indicates that your server expects to receive an authorization code
      </li>
      <li>
       <b>
        client_id
       </b>
       - The client ID you received when you first created the application
      </li>
      <li>
       <b>
        redirect_uri
       </b>
       - Indicates the URI to return the user to after authorization is complete
      </li>
      <li>
       <b>
        scope
       </b>
       - One or more scope values indicating which parts of the user's account you wish to access
      </li>
      <li>
       <b>
        state
       </b>
       - A random string generated by your application, which you'll verify later
      </li>
     </ul>
     <p>
      The user sees the authorization prompt
     </p>
     <p>
      <img alt="OAuth Authorization Prompt" src="https://aaronparecki.com/oauth-2-simplified/oauth-authorization-prompt.png"/>
     </p>
     <p>
      If the user clicks "Allow," the service redirects the user back to your site with an authorization code
     </p>
     <pre><code>https://example-app.com/cb?code=AUTH_CODE_HERE&amp;state=1234zyx</code></pre>
     <ul>
      <li>
       <b>
        code
       </b>
       - The server returns the authorization code in the query string
      </li>
      <li>
       <b>
        state
       </b>
       - The server returns the same state value that you passed
      </li>
     </ul>
     <p>
      You should first compare this state value to ensure it matches the one you started with. You can typically store the state value in a cookie or session, and compare it when the user comes back. This helps ensure your redirection endpoint isn't able to be tricked into attempting to exchange arbitrary authorization codes.
     </p>
     <h3>
      Getting an Access Token
     </h3>
     <p>
      Your server exchanges the authorization code for an access token by making a POST request to the authorization server's token endpoint:
     </p>
     <pre><code>POST https://api.authorization-server.com/token
  grant_type=authorization_code&amp;
  code=AUTH_CODE_HERE&amp;
  redirect_uri=REDIRECT_URI&amp;
  client_id=CLIENT_ID&amp;
  client_secret=CLIENT_SECRET</code></pre>
     <ul>
      <li>
       <b>
        grant_type=authorization_code
       </b>
       - The grant type for this flow is authorization_code
      </li>
      <li>
       <b>
        code=AUTH_CODE_HERE
       </b>
       - This is the code you received in the query string
      </li>
      <li>
       <b>
        redirect_uri=REDIRECT_URI
       </b>
       - Must be identical to the redirect URI provided in the original link
      </li>
      <li>
       <b>
        client_id=CLIENT_ID
       </b>
       - The client ID you received when you first created the application
      </li>
      <li>
       <b>
        client_secret=CLIENT_SECRET
       </b>
       - Since this request is made from server-side code, the secret is included
      </li>
     </ul>
     <p>
      The server replies with an access token and expiration time
     </p>
     <pre><code>{
  "access_token":"RsT5OjbzRn430zqMLgV3Ia",
  "expires_in":3600
}</code></pre>
     <p>
      or if there was an error
     </p>
     <pre><code>{
  "error":"invalid_request"
}</code></pre>
     <p>
      Security: Note that the service must require apps to pre-register their redirect URIs.
     </p>
     <p>
      <span id="browser-based-apps">
      </span>
     </p>
     <h2 id="single-page-apps">
      Single-Page Apps
     </h2>
     <p>
      Single-page apps (or browser-based apps) run entirely in the browser after loading the source code from a web page. Since the entire source code is available to the browser, they cannot maintain the confidentiality of a client secret, so the secret is not used in this case. The flow is based on the authorization code flow above, but with the addition of a dynamically generated secret used on each request. This is known as the
      <a href="https://oauth.net/2/pkce">
       PKCE
      </a>
      extension.
     </p>
     <div class="inline-banner">
      <p>
       Note: Previously, it was recommended that browser-based apps use the "Implicit" flow, which returns an access token immediately in the redirect and does not have a token exchange step. In the time since the spec was originally written, the industry best practice has changed to recommend that the authorization code flow be used without the client secret. This provides more opportunities to create a secure flow, such as using the
       <a href="https://oauth.net/2/pkce/">
        PKCE extension
       </a>
       . Further reading:
       <a href="https://tools.ietf.org/html/draft-ietf-oauth-security-topics">
        OAuth 2.0 Security Best Current Practice
       </a>
       (ietf.org),
       <a href="https://tools.ietf.org/html/draft-parecki-oauth-browser-based-apps">
        OAuth 2.0 for Browser-Based Apps
       </a>
       (ietf.org).
      </p>
     </div>
     <h3>
      Authorization
     </h3>
     <p>
      Create a random string between 43-128 characters long, then generate the url-safe base64-encoded SHA256 hash of the string. The original random string is known as the
      <code>
       code_verifier
      </code>
      , and the hashed version is known as the
      <code>
       code_challenge
      </code>
      .
     </p>
     <p>
      Create a random string (code verifier), e.g.
      <code>
       5d2309e5bb73b864f989753887fe52f79ce5270395e25862da6940d5
      </code>
     </p>
     <p>
      Create the SHA256 hash, then base64-encode the string (code challenge):
      <code>
       MChCW5vD-3h03HMGFZYskOSTir7II_MMTb8a9rJNhnI
      </code>
     </p>
     <p>
      (You can use the helper utility at
      <a href="https://example-app.com/pkce">
       example-app.com/pkce
      </a>
      to generate a secret and hash.)
     </p>
     <p>
      Create a "Log In" link like the authorization code flow above, but now include the code challenge in the request:
     </p>
     <pre><code>https://authorization-server.com/auth?response_type=code&amp;
  client_id=CLIENT_ID&amp;redirect_uri=REDIRECT_URI&amp;scope=photos&amp;state=1234zyx&amp;code_challenge=CODE_CHALLENGE&amp;code_challenge_method=S256</code></pre>
     <ul>
      <li>
       <b>
        response_type=code
       </b>
       - Indicates that your server expects to receive an authorization code
      </li>
      <li>
       <b>
        client_id
       </b>
       - The client ID you received when you first created the application
      </li>
      <li>
       <b>
        redirect_uri
       </b>
       - Indicates the URI to return the user to after authorization is complete
      </li>
      <li>
       <b>
        scope
       </b>
       - One or more scope values indicating which parts of the user's account you wish to access
      </li>
      <li>
       <b>
        state
       </b>
       - A random string generated by your application, which you'll verify later
      </li>
      <li>
       <b>
        code_challenge
       </b>
       - The URL-safe base64-encoded SHA256 hash of the secret
      </li>
      <li>
       <b>
        code_challenge_method=S256
       </b>
       - Indicate which hashing method you used (S256)
      </li>
     </ul>
     <p>
      The user sees the authorization prompt
     </p>
     <p>
      <img alt="OAuth Authorization Prompt" src="https://aaronparecki.com/oauth-2-simplified/oauth-authorization-prompt.png"/>
     </p>
     <p>
      If the user clicks "Allow," the service redirects the user back to your site with an auth code
     </p>
     <pre><code>https://example-app.com/cb?code=AUTH_CODE_HERE&amp;state=1234zyx</code></pre>
     <ul>
      <li>
       <b>
        code
       </b>
       - The server returns the authorization code in the query string
      </li>
      <li>
       <b>
        state
       </b>
       - The server returns the same state value that you passed
      </li>
     </ul>
     <p>
      You should first compare this state value to ensure it matches the one you started with. You can typically store the state value in a cookie, and compare it when the user comes back. This ensures your redirection endpoint isn't able to be tricked into attempting to exchange arbitrary authorization codes.
     </p>
     <p>
      You can find a complete example of using PKCE in JavaScript in my blog post
      <a href="https://developer.okta.com/blog/2019/05/01/is-the-oauth-implicit-flow-dead">
       Is the OAuth Implicit Flow Dead?
      </a>
     </p>
     <h3>
      Getting an Access Token
     </h3>
     <p>
      Now you'll need to exchange the authorization code for an access token, but instead of providing a pre-registered client secret, you send the PKCE secret you generated at the beginning of the flow.
     </p>
     <pre><code>POST https://api.authorization-server.com/token
  grant_type=authorization_code&amp;
  code=AUTH_CODE_HERE&amp;
  redirect_uri=REDIRECT_URI&amp;
  client_id=CLIENT_ID&amp;
  code_verifier=CODE_VERIFIER</code></pre>
     <ul>
      <li>
       <b>
        grant_type=authorization_code
       </b>
       - The grant type for this flow is authorization_code
      </li>
      <li>
       <b>
        code=AUTH_CODE_HERE
       </b>
       - This is the code you received in the query string
      </li>
      <li>
       <b>
        redirect_uri=REDIRECT_URI
       </b>
       - Must be identical to the redirect URI provided in the original link
      </li>
      <li>
       <b>
        client_id=CLIENT_ID
       </b>
       - The client ID you received when you first created the application
      </li>
      <li>
       <b>
        code_verifier=CODE_VERIFIER
       </b>
       - The random secret you generated at the beginning
      </li>
     </ul>
     <p>
      The authorization server will hash the verifier and compare it to the challenge sent in the request, and only issue the access token if they match. This ensures that even if someone was able to intercept the authorization code, they will not be able to use it to get an access token since they won't have the secret.
     </p>
     <h2 id="mobile-apps">
      Mobile Apps
     </h2>
     <p>
      Like browser-based apps, mobile apps also cannot maintain the confidentiality of a client secret. Because of this, mobile apps also use the PKCE flow which does not require a client secret. There are some additional concerns that mobile apps should keep in mind to ensure the security of the OAuth flow.
     </p>
     <p class="inline-banner">
      Note: Previously, it was recommended that mobile and native apps use the Implicit grant. In the time since the spec was originally written, the industry best practice has changed to recommend using the authorization code flow with no secret for native apps. There are some
      <a href="https://tools.ietf.org/html/rfc8252">
       additional recommendations
      </a>
      for native apps that are worth reading as well.
     </p>
     <h3>
      Authorization
     </h3>
     <p>
      Create a "Log in" button sending the user to either the native app of the service on the phone, or a mobile web page for the service. Apps can register a custom URI scheme such as "example-app://" so the native app is launched whenever a URL with that protocol is visited, or they can register URL patterns which will launch the native app if a URL matching the pattern is visited.
     </p>
     <h4>
      Using the Service's Native App
     </h4>
     <p>
      If the user has the native Facebook app installed, direct them to the following URL:
     </p>
     <pre><code>fbauth2://authorize?response_type=code&amp;client_id=CLIENT_ID
  &amp;redirect_uri=REDIRECT_URI&amp;scope=email&amp;state=1234zyx</code></pre>
     <ul>
      <li>
       <b>
        response_type=code
       </b>
       - indicates that your server expects to receive an authorization code
      </li>
      <li>
       <b>
        client_id=CLIENT_ID
       </b>
       - The client ID you received when you first created the application
      </li>
      <li>
       <b>
        redirect_uri=REDIRECT_URI
       </b>
       - Indicates the URI to return the user to after authorization is complete, such as
       <code>
        fb00000000://authorize
       </code>
      </li>
      <li>
       <b>
        scope=email
       </b>
       - One or more scope values indicating which parts of the user's account you wish to access
      </li>
      <li>
       <b>
        state=1234zyx
       </b>
       - A random string generated by your application, which you'll verify later
      </li>
     </ul>
     <p>
      For servers that support the
      <a href="https://oauth.net/2/pkce/">
       PKCE extension
      </a>
      (and if you're building a server, you should support the PKCE extension), you'll also include the following parameters. First, create a "code verifier" which is a random string that the app stores locally.
     </p>
     <ul>
      <li>
       <b>
        code_challenge=XXXXXXX
       </b>
       - This is a base64-encoded version of the sha256 hash of the code verifier string
      </li>
      <li>
       <b>
        code_challenge_method=S256
       </b>
       - Indicates the hashing method used to compute the challenge, in this case, sha256.
      </li>
     </ul>
     <p>
      Note that your redirect URI will probably look like
      <code>
       fb00000000://authorize
      </code>
      where the protocol is a custom URL scheme that your app has registered with the OS.
     </p>
     <h4>
      Using a Web Browser
     </h4>
     <p>
      If the service does not have a native application, you can launch a mobile browser to the standard web authorization URL. Note that you should never use an embedded web view in your own application, as this provides the user no guarantee that they are actually are entering their password in the service's website rather than a phishing site.
     </p>
     <p>
      You should either launch the native mobile browser, or use the new iOS "SafariViewController" to launch an embedded browser in your application. This API was added in iOS 9, and provides a mechanism to launch a browser inside the application that both shows the address bar so the user can confirm they're on the correct website, and also shares cookies with the real Safari browser. It also prevents the application from inspecting and modifying the contents of the browser, so can be considered secure.
     </p>
     <pre><code>https://facebook.com/dialog/oauth?response_type=code&amp;client_id=CLIENT_ID
  &amp;redirect_uri=REDIRECT_URI&amp;scope=email&amp;state=1234zyx</code></pre>
     <p>
      Again, if the service supports PKCE, then those parameters should be included as well as described above.
     </p>
     <ul>
      <li>
       <b>
        response_type=code
       </b>
       - indicates that your server expects to receive an authorization code
      </li>
      <li>
       <b>
        client_id=CLIENT_ID
       </b>
       - The client ID you received when you first created the application
      </li>
      <li>
       <b>
        redirect_uri=REDIRECT_URI
       </b>
       - Indicates the URI to return the user to after authorization is complete, such as
       <code>
        fb00000000://authorize
       </code>
      </li>
      <li>
       <b>
        scope=email
       </b>
       - One or more scope values indicating which parts of the user's account you wish to access
      </li>
      <li>
       <b>
        state=1234zyx
       </b>
       - A random string generated by your application, which you'll verify later
      </li>
     </ul>
     <p>
      The user will see the authorization prompt
     </p>
     <p>
      <img alt="Facebook Authorization Prompt" src="https://aaronparecki.com/oauth-2-simplified/everyday-city-auth.png"/>
     </p>
     <h3>
      Getting an Access Token
     </h3>
     <p>
      After clicking "Approve", the user will be redirected back to your application with a URL like
     </p>
     <pre><code>fb00000000://authorize?code=AUTHORIZATION_CODE&amp;state=1234zyx</code></pre>
     <p>
      Your mobile application should first verify that the state corresponds to the state that was used in the initial request, and can then exchange the authorization code for an access token.
     </p>
     <p>
      The token exchange will look the same as exchanging the code in the web server app case, except that the secret is not sent. If the server supports PKCE, then you will need to include an additional parameter as described below.
     </p>
     <pre><code>POST https://api.authorization-server.com/token
  grant_type=authorization_code&amp;
  code=AUTH_CODE_HERE&amp;
  redirect_uri=REDIRECT_URI&amp;
  client_id=CLIENT_ID&amp;
  code_verifier=VERIFIER_STRING</code></pre>
     <ul>
      <li>
       <b>
        grant_type=authorization_code
       </b>
       - The grant type for this flow is authorization_code
      </li>
      <li>
       <b>
        code=AUTH_CODE_HERE
       </b>
       - This is the code you received in the query string
      </li>
      <li>
       <b>
        redirect_uri=REDIRECT_URI
       </b>
       - Must be identical to the redirect URI provided in the original link
      </li>
      <li>
       <b>
        client_id=CLIENT_ID
       </b>
       - The client ID you received when you first created the application
      </li>
      <li>
       <b>
        code_verifier=VERIFIER_STRING
       </b>
       - The plaintext string that you previously hashed to create the code_challenge
      </li>
     </ul>
     <p>
      The authorization server will verify this request and return an access token.
     </p>
     <p>
      If the server supports PKCE, then the authorization server will recognize that this code was generated with a code challenge, and will hash the provided plaintext and confirm that the hashed version corresponds with the hashed string that was sent in the initial authorization request. This ensures the security of using the authorization code flow with clients that don't support a secret.
     </p>
     <h2 id="others">
      Other Grant Types
     </h2>
     <h3 id="password">
      Password
     </h3>
     <p>
      OAuth 2 also provides a "password" grant type which can be used to exchange a username and password for an access token directly. Since this obviously requires the application to collect the user's password, it must only be used by apps created by the service itself. For example, the native Twitter app could use this grant type to log in on mobile or desktop apps.
     </p>
     <p>
      To use the password grant type, simply make a POST request like the following:
     </p>
     <pre><code>POST https://api.authorization-server.com/token
  grant_type=password&amp;
  username=USERNAME&amp;
  password=PASSWORD&amp;
  client_id=CLIENT_ID</code></pre>
     <ul>
      <li>
       <b>
        grant_type=password
       </b>
       - The grant type for this flow is password
      </li>
      <li>
       <b>
        username=USERNAME
       </b>
       - The user's username as collected by the application
      </li>
      <li>
       <b>
        password=PASSWORD
       </b>
       - The user's password as collected by the application
      </li>
      <li>
       <b>
        client_id=CLIENT_ID
       </b>
       - The client ID you received when you first created the application
      </li>
     </ul>
     <p>
      The server replies with an access token in the same format as the other grant types.
     </p>
     <p>
      Note, the client secret is not included here under the assumption that most of the use cases for password grants will be mobile or desktop apps, where the secret cannot be protected.
     </p>
     <h3 id="client-credentials">
      Application access
     </h3>
     <p>
      In some cases, applications may need an access token to act on behalf of themselves rather than a user. For example, the service may provide a way for the application to update their own information such as their website URL or icon, or they may wish to get statistics about the users of the app. In this case, applications need a way to get an access token for their own account, outside the context of any specific user. OAuth provides the
      <code>
       client_credentials
      </code>
      grant type for this purpose.
     </p>
     <p>
      To use the client credentials grant type, make a POST request like the following:
     </p>
     <pre><code>POST https://api.authorization-server.com/token
    grant_type=client_credentials&amp;
    client_id=CLIENT_ID&amp;
    client_secret=CLIENT_SECRET</code></pre>
     <p>
      The response will include an access token in the same format as the other grant types.
     </p>
     <h2 id="making-authenticated-requests">
      Making Authenticated Requests
     </h2>
     <p>
      The end result of all the grant types is obtaining an access token.
     </p>
     <p>
      Now that you have an access token, you can make requests to the API. You can quickly make an API request using cURL as follows:
     </p>
     <pre><code>curl -H "Authorization: Bearer RsT5OjbzRn430zqMLgV3Ia" \
https://api.authorization-server.com/1/me
</code></pre>
     <p>
      That's it! Make sure you always send requests over HTTPS and never ignore invalid certificates. HTTPS is the only thing protecting requests from being intercepted or modified.
     </p>
     <h2 id="differences">
      Differences from OAuth 1.0
     </h2>
     <p>
      OAuth 1.0 was largely based on existing proprietary protocols such as Flickr's "FlickrAuth" and Google's "AuthSub". The result represented the best solution based on actual implementation experience. However, after several years of working with the protocol, the community learned enough to rethink and improve the protocol in three main areas where OAuth 1.0 proved limited or confusing.
     </p>
     <p>
      You can read more about this in detail in my book
      <a href="https://www.oauth.com/oauth2-servers/differences-between-oauth-1-2/">
       OAuth 2.0 Simplified
      </a>
      .
     </p>
     <h2 id="resources">
      Resources
     </h2>
     <ul>
      <li>
       OAuth 2.0 Simplified - the book
       <a href="https://oauth2simplified.com">
        oauth2simplified.com
       </a>
      </li>
      <li>
       Learn more about
       <a href="https://www.oauth.com/">
        creating OAuth 2.0 Servers
       </a>
      </li>
      <li>
       <a href="https://tools.ietf.org/html/rfc7636">
        PKCE Extension
       </a>
      </li>
      <li>
       <a href="https://tools.ietf.org/html/draft-ietf-oauth-native-apps-07">
        Recommendations for Native Apps
       </a>
      </li>
      <li>
       More information is available on
       <a href="https://oauth.net">
        OAuth.net
       </a>
      </li>
      <li>
       Some content adapted from
       <a href="http://hueniverse.com">
        hueniverse.com
       </a>
       .
      </li>
     </ul>
     <div style="border: 3px #444 solid; background: #eee; border-radius: 4px; padding: 10px 20px; display: inline-block; float: right;">
      <a href="https://aaronparecki.com/tip/">
       💵 Tip Jar 🍻
      </a>
     </div>
     <p>
      Previous versions of this post:
     </p>
     <ul>
      <li>
       <a href="https://aaronparecki.com/2012/07/29/7/oauth2-simplified">
        July 2012
       </a>
      </li>
     </ul>
     <div class="inline-author-info">
      <h3>
       About the Author
      </h3>
      <img src="/images/profile.jpg" style="float: left; border-radius: 55px; margin-right: 4px;" width="110"/>
      <p>
       Aaron Parecki is the author of
       <a href="https://oauth2simplified.com/">
        OAuth 2.0 Simplified
       </a>
       , maintains
       <a href="https://oauth.net">
        oauth.net
       </a>
       , and is the editor of several W3C specifications.
      </p>
      <p>
       Want Aaron Parecki to come to your meetup and give a talk on OAuth?
       <a href="/oauth/">
        Request a presentation from Aaron
       </a>
       .
      </p>
      <div style="clear:both;">
      </div>
     </div>
     <style type="text/css">
      .inline-banner {
  border: 1px #FEF199 solid;
  border-radius: 6px;
  padding: 4px;
  background-color: #FFFAB4;
  font-size: 0.9em;
  line-height: 1.4em;
}
.inline-author-info {
  border: 1px #00A0D8 solid;
  border-radius: 4px;
  padding: 6px;
  background-color: #fafafa;
  font-size: 0.9em;
  line-height: 1.4em;
}
     </style>
    </div>
   </div>
   <div class="metaline pad">
    <a class="u-url" href="https://aaronparecki.com/oauth-2-simplified">
     permalink
    </a>
   </div>
   <a class="u-author" href="/">
   </a>
   <div style="clear:both;">
   </div>
  </div>
 </body>
</html>
